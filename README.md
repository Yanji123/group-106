# group-106  
小组中的成员为：  
崔若锦 202100460014 负责project：4 5 8 17 19  
梁芮豪 202100460 负责project：  
潘浩洋 202100460136 负责project：1 2 3 9  

## project1  
这部分该部分由小组中的潘浩洋同学完成，

## project2  
## project3  
## project4  
该部分由小组成员崔若锦完成  
实验设备：  
12th Gen Intel(R) Core(TM) i7-12700H   2.30 GHz  
实验环境：  
C++：Visual Studio 2022  
python：PyCharm 2022.2.3  
（后续实验环境不变，不再赘述）  
国密算法SM3的执行过程可以概括为四个步骤：消息填充、消息扩展、迭代压缩、输出结果。下面将详细说明每个步骤：

### 1. 消息填充：
SM3算法采用Merkle-Damgard结构，在处理消息时，首先将消息进行填充，使其长度能够被512位整除。填充规则为在消息末尾添加一个"1"比特，然后添加若干个"0"比特，直到满足消息长度对512取模等于448。剩余的64位用来表示原始消息的长度，以比特为单位。

### 2. 消息扩展：
在填充后的消息基础上，进行消息扩展。将512位的消息分成16个64位的消息分组，然后通过扩展算法产生48个64位的字，用于后续的迭代压缩过程。

### 3. 迭代压缩：
迭代压缩是SM3算法的核心步骤，它通过64轮的迭代运算来混淆和压缩消息。在每一轮迭代中，使用消息扩展得到的字与初始的256位哈希值之间进行一系列的位运算和置换操作，从而逐渐更新哈希值。

### 4. 输出结果：
经过64轮迭代压缩后，最终得到256位的哈希值，即SM3算法的输出结果。该哈希值可以用作数字签名和验证，具有较高的安全性，满足密码应用中的要求。

总结来说，SM3算法是一种用于密码杂凑的算法，通过消息填充、消息扩展、迭代压缩等步骤将输入消息转换为256位的哈希值。它具有多项式时间可计算、单向性、认证性和抗碰撞性等特性，适用于数字签名和验证等商用密码应用。
### 优化方向：  
优化前：  
计算前16个wi时，每个需要执行一次load和一个store，计算后52个wi时，每个需要执行5次load，1次store，6次XOR和1次rot；  
计算64个wi，每个wi需要执行2次load，1次store和1次rot。  
优化后：  
在计算前 12 个 wi+4 时，每个都需要执行一次加载和一次保存。 在计算最后52个wi+4时，每个需要进行5次load，1次store，6次XOR，4次rot；  
主要是减少计算和存储W'时的存取操作。 在测试中，优化也提高了算法的执行速度
### 运行结果：
未加密的明文:cuirujin加密中...  
SM3加密后的密文:6e0f9e14344c5406aOcf5a3b4dfb665f87f4a771a31f7edbb5c72874a32b29571加密时间为:9.38 ms  
解密中...  
解密时间为:17.22 ms  
（没查图片就图文识别了一下）  

## project5  
## project8  
## project9  
## project17  
## project19  
## project5  
